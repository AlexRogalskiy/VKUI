<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <title>Force layout (with links)</title>
</head>

<style>
circle {
  fill: cadetblue;
}
line {
  stroke: #ccc;
}
text {
  text-anchor: middle;
  font-family: "Helvetica Neue", Helvetica, sans-serif;
  fill: #666;
  font-size: 16px;
}
</style>

<body>
  <div id="content">
    <svg width="1500" height="1500">
      <g class="links"></g>
      <g class="nodes"></g>
    </svg>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.2.2/d3.min.js"></script>

  <script>
var width = 1500, height = 1500


var nodes = new Set();

var links = [
  { from: "AppRoot", to: "vkui" },
  { from: "Avatar", to: "PanelHeader" },
  { from: "Avatar", to: "RichCell" },
  { from: "Avatar", to: "SimpleCell" },
  { from: "Badge", to: "SimpleCell" },
  { from: "Badge", to: "TabbarItem" },
  { from: "Badge", to: "TabsItem" },
  { from: "Button", to: "Banner" },
  { from: "Button", to: "ModalCard" },
  { from: "Button", to: "Placeholder" },
  { from: "Button", to: "RichCell" },
  { from: "Card", to: "CardGrid" },
  { from: "Card", to: "CardScroll" },
  { from: "Cell", to: "FormItem" },
  { from: "CellButton", to: "FormItem" },
  { from: "Checkbox", to: "FormItem" },
  { from: "FormField", to: "ModalCard" },
  { from: "FormItem", to: "FormLayoutGroup" },
  { from: "Header", to: "Group" },
  { from: "HorizontalScroll", to: "Tabs" },
  { from: "Panel", to: "View" },
  { from: "PanelHeader", to: "Panel" },
  { from: "PanelHeaderButton", to: "ModalPageHeader" },
  { from: "PanelHeaderButton", to: "PanelHeader" },
  { from: "Radio", to: "FormItem" },
  { from: "Removable", to: "FormItem" },
  { from: "Removable", to: "FormLayoutGroup" },
  { from: "RichCell", to: "FormItem" },
  { from: "Search", to: "PanelHeader" },
  { from: "Separator", to: "ModalPage" },
  { from: "Separator", to: "Tabs" },
  { from: "SimpleCell", to: "Cell" },
  { from: "SimpleCell", to: "CellButton" },
  { from: "SimpleCell", to: "FormItem" },
  { from: "Switch", to: "SimpleCell" },
  { from: "Tabs", to: "Group" },
  { from: "UsersStack", to: "MiniInfoCell" },
  { from: "UsersStack", to: "ModalCard" },
  { from: "UsersStack", to: "RichCell" },
];


const handled = new Set([]);
links = links.filter(l => !handled.has(l.from) && !handled.has(l.to));
console.log(tsort(links.map(l => [l.from, l.to])));
links.forEach(l => nodes.add(l.from).add(l.to));

const levels = [];
let sorting = Array.from(nodes).slice();
while (sorting.length) {
    const sorted = levels.reduce((sorted, lvl) => {
        lvl.forEach(n => sorted.add(n));
        return sorted;
    }, new Set());
    const currentLevel = new Set(sorting.filter(node => {
        const targets = links.filter(l => l.to === node).map(l => l.from);
        return targets.every(node => sorted.has(node));
    }));
    console.log(currentLevel);
    levels.push(currentLevel);
    sorting = sorting.filter(node => !currentLevel.has(node));
}
levels.forEach((l, i) => console.log(i, Array.from(l).join('\n')));

nodes = Array.from(nodes).map(name => ({ name }));
links = links.map(l => ({
    source: nodes.findIndex(n => n.name === l.from),
    target: nodes.findIndex(n => n.name === l.to),
}))

var simulation = d3.forceSimulation(nodes)
  .force('charge', d3.forceManyBody().strength(-200))
  .force('center', d3.forceCenter(width / 2, height / 2))
  .force('link', d3.forceLink().links(links))
  .on('tick', ticked);

function updateLinks() {
  var u = d3.select('.links')
    .selectAll('line')
    .data(links)

  u.enter()
    .append('line')
    .merge(u)
    .attr('x1', function(d) {
      return d.source.x
    })
    .attr('y1', function(d) {
      return d.source.y
    })
    .attr('x2', function(d) {
      return d.target.x
    })
    .attr('y2', function(d) {
      return d.target.y
    })

  u.exit().remove()
}

function updateNodes() {
  u = d3.select('.nodes')
    .selectAll('text')
    .data(nodes)

  u.enter()
    .append('text')
    .text(function(d) {
      return d.name
    })
    .merge(u)
    .attr('x', function(d) {
      return d.x
    })
    .attr('y', function(d) {
      return d.y
    })
    .attr('dy', function(d) {
      return 5
    })

  u.exit().remove()
}

function ticked() {
  updateLinks()
  updateNodes()
}


function tsort(edges) {
  var nodes   = {}, // hash: stringified id of the node => { id: id, afters: lisf of ids }
      sorted  = [], // sorted list of IDs ( returned value )
      visited = {}; // hash: id of already visited node => true

  var Node = function(id) {
    this.id = id;
    this.afters = [];
  }

  // 1. build data structures
  edges.forEach(function(v) {
    var from = v[0], to = v[1];
    if (!nodes[from]) nodes[from] = new Node(from);
    if (!nodes[to]) nodes[to]     = new Node(to);
    nodes[from].afters.push(to);
  });

  // 2. topological sort
  Object.keys(nodes).forEach(function visit(idstr, ancestors) {
    var node = nodes[idstr],
        id   = node.id;

    // if already exists, do nothing
    if (visited[idstr]) return;

    if (!Array.isArray(ancestors)) ancestors = [];

    ancestors.push(id);

    visited[idstr] = true;

    node.afters.forEach(function(afterID) {
      if (ancestors.indexOf(afterID) >= 0)  // if already in ancestors, a closed chain exists.
        throw new Error('closed chain : ' +  afterID + ' is in ' + id);

      visit(afterID.toString(), ancestors.map(function(v) { return v })); // recursive call
    });

    sorted.unshift(id);
  });

  return sorted;
}

  </script>
</body>
</html>